{"meta":{"title":"sing's blog","subtitle":"","description":"","author":"Sing","url":"https://singingxy.github.io","root":"/"},"posts":[{"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://singingxy.github.io/tags/VS-Code/"},{"name":"Eslint","slug":"Eslint","permalink":"https://singingxy.github.io/tags/Eslint/"}],"title":"VSCode升级，ESLint自动修复的设置更新","date":"2020/01/14","text":"VS Code 升级后有关 ESlint 自动修复的配置有变更。在settings.json文件中发现了如下报错这个设置项已经弃用了，请使用 editor.codeActionsOnSave 和 source.fixAll.eslint。 于是改成了下面这样： \"editor.codeActionsOnSave\": &#123; //在保存时运行以下 \"source.fixAll.eslint\": true // 开启eslint格式化工具 &#125; 下面还有一个报错： Auto Fix is enabled by default. Use the single string form. 默认情况下Auto Fix已经启用了。 官方介绍是这么写的： eslint.probe = an array for language identifiers for which the ESLint extension should be activated and should try to validate the file. If validation fails for probed languages the extension says silent. Defaults to [&quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;typescript&quot;, &quot;typescriptreact&quot;, &quot;html&quot;, &quot;vue&quot;]. eslint.validate - an array of language identifiers specifying the files for which validation is to be enforced. This is an old legacy setting and should in normal cases not be necessary anymore. Defaults to [&quot;javascript&quot;, &quot;javascriptreact&quot;]. eslint.validate这个旧的属性已经不再需要了，而新属性eslint.probe默认值已经加入了vue和html文件的验证。 进到扩展设置里可看到这一项: 所以修改方法就是把eslint.validate这一项删除就好了。","permalink":"https://singingxy.github.io/2020/vscode-eslint/","photos":[]},{"tags":[{"name":"flex","slug":"flex","permalink":"https://singingxy.github.io/tags/flex/"},{"name":"css","slug":"css","permalink":"https://singingxy.github.io/tags/css/"}],"title":"flex布局","date":"2020/01/02","text":"flex（ Flexible Box：弹性布局盒模型），用来为盒模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。可以做到简便、完整、响应式地实现各种页面布局。 使用 flex 布局的优势 可在不同方向排列元素 控制元素排序的方向 控制元素的对齐方式 控制元素之间等距 基本概念 flex container: Flex 容器 flex item: Flex 项目（元素） flex direction: 布局方向 Flex 容器的所有子元素自动成为 Flex 项目。 在 flex 容器中默认存在两条轴，主轴(main axis) 和交叉轴(cross axis)，默认水平方向为主轴，垂直方向为交叉轴，也可以通过修改使垂直方向变为主轴，水平方向变为交叉轴。 Flex 容器的属性1. flex-direction: 决定主轴的方向（元素的排列方向）.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row（默认）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 2. flex-wrap: 决定容器内项目是否可换行.container &#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 3. justify-content：定义了项目在主轴的对齐方式.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around; &#125; flex-start（默认）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等，剩余空间等分成间隙space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 4. align-items: 定义了项目在交叉轴上的对齐方式.container &#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125; flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 5. align-content: 定义了多根轴线的对齐方式（如果项目只有一根轴线，那么该属性将不起作用）.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 Flex 项目属性1. order：控制元素顺序定义项目的排列顺序。数值越小，排列越靠前，默认为 0。可以为负 2. flex-grow: 控制元素放大比例定义项目的放大比例，默认为 0，值为 0 时不进行放大。 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink: 控制元素缩小比例定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小，负值对该属性无效。设置为 0 时不缩小。 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 4. flex-basis: 设置元素固定或自动空间的占比定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小，这时候 item 的宽高取决于 width 或 height 的值。若值为 0，则必须加上单位，以免被视作伸缩性。 当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。 当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。 当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。 5. align-self:重写 align-item 父属性允许单个项目有与其他项目不一样的对齐方式。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 .item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; &#125;","permalink":"https://singingxy.github.io/2020/flex/","photos":[]},{"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://singingxy.github.io/tags/MVVM/"},{"name":"MVC","slug":"MVC","permalink":"https://singingxy.github.io/tags/MVC/"}],"title":"理解MVVM","date":"2019/12/28","text":"MVVM 是由 MVC 发展而来，通过在 Model 之上而在 View 之下增加一个非视觉的组件将来自 Model 的数据映射到 View 中。 MVC(Model-View-Controller) 视图（View）：用户界面，展示 UI 界面和响应用户交互 控制器（Controller）：业务逻辑，监听模型数据的改变和控制视图行为、处理用户交互 模型（Model）：数据保存 简单来说就是通过 controller 的控制去操作 model 层的数据，并且返回给 view 层展示。 View 接受用户交互请求 View 将请求转交给 Controller 处理 Controller 操作 Model 进行数据更新保存 数据更新保存之后，Model 会通知 View 更新 View 更新，用户得到反馈 MVVM(Model-View-ViewModel)MVVM 是在 MVC 模式之后引出的新的开发模式，他与 MVC 模式一样用于把视图（界面）和数据进行解耦，不同的是采用 ViewModel 来完成数据与视图的双向绑定，通过自动化的方式承担大部分数据工作，来解决由于界面复杂化和快速迭代带来的问题。MVVM 将其中的 View 的状态和行为抽象化，让我们可以将 UI 和业务逻辑分开。MVVM 的优点是低耦合、可重用性、独立开发。 View 接收用户交互请求 View 将请求转交给 ViewModel ViewModel 操作 Model 数据更新 Model 更新完数据，通知 ViewModel 数据发生变化 ViewModel 更新 View 数据 不同之处MVVM 模式和 MVC 有些类似，但有以下不同： ViewModel 替换了 Controller，在 UI 层之下 ViewModel 向 View 暴露它所需要的数据和指令对象 ViewModel 接收来自 Model 的数据","permalink":"https://singingxy.github.io/2019/Introduction-to-MVVM/","photos":[]},{"tags":[{"name":"ssh","slug":"ssh","permalink":"https://singingxy.github.io/tags/ssh/"},{"name":"Git","slug":"Git","permalink":"https://singingxy.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://singingxy.github.io/tags/Github/"}],"title":"使用ssh连接Git仓库(Github\\GitLab\\CODING\\码云等)","date":"2019/12/23","text":"总的说主要操作是在本地生成 ssh Key，然后把 ssh Key 添加到 Github/GitLab 的账户上，完成连接。 检查现有 ssh 密钥打开 Git Bash 终端。 输入 ls -al ~/.ssh 查看是否已经存在 ssh 密钥： \\$ ls -al ~/.ssh 如果提示不存在此目录那么就来生成新 ssh 密钥 如果已经存在 ssh 密匙文件应该是长下面这个样子： id_rsa.pubid_ecdsa.pubid_ed25519.pub就可以跳过创建 SSH 密钥这一步啦。 生成新 ssh 密钥打开 Git Bash 终端输入ssh-keygen -t rsa -C &lt;your_email@example.com&gt;( 你的邮箱) ssh-keygen -t rsa -b 4096 -C &lt;your_email@example.com&gt; # Creates a new ssh key, using the provided email as a label # Generating public/private rsa key pair. Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] //enter使用默认地址， 如果需要使用多个Git仓库可以重命名 Enter passphrase (empty for no passphrase): //这里点击 Enter 键即可，也可以填写密码，填写密码后每次使用 ssh 方式推送代码时都会要求输入密码 成功之后显示如下信息： Your identification has been saved in /Users/you/.ssh/id_rsa. # Your public key has been saved in /Users/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 给账户添加 ssh到路径/Users/用户名/.ssh/下，使用编辑器打开刚刚创建的id_rsa.pub文件，复制下整段内容。打开 Github\\GitLab\\CODING\\码云 的账户设置，找到设置 ssh 的选项，点击新增 ssh 密钥。由于各网站的设置位置都有不同，就不一一详说了。把刚刚复制的 Key 粘贴进去，可以起一个方便你分辨的名字。然后会提示你输入密码，输入完毕后 ssh Key 就添加成功了。 测试 ssh 连接在 Git Bash 里使用命令ssh -T git@github.com测试 ssh 连接，如果是 GitLab 则是ssh -T git@gitlab.com，其他账户同理。 ssh -T git@github.com &gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established. &gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. &gt; Are you sure you want to continue connecting (yes/no)? //输入 yes &gt; Hi username! You've successfully authenticated, but GitHub does not &gt; provide shell access. 收到欢迎消息说明连接成功。 使用 VS Code 尝试同步把要用的仓库 clone 到本地，放进 vscode 工作区，修改一些内容，可以看到改动的内容被识别出来了。push 一下试试，输入用户名密码，成功。如果密码输错了可以修改凭据 如何修改本地提交时记录的密码控制面板-用户账户-管理 Windows 凭据-找到要修改的那一个，点编辑就可以修改密码了。","permalink":"https://singingxy.github.io/2019/sshKey-Git/","photos":[]},{"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://singingxy.github.io/tags/HTTP/"}],"title":"HTTP请求","date":"2019/12/13","text":"一个完整的 HTTP 请求过程 建立 TCP 连接 Web 浏览器向 Web 服务器发送请求命令 Web 浏览器发送请求头信息 Web 服务器应答 Web 服务器发送应答头信息 Web 服务器向浏览器发送数据 Web 服务器关闭 TCP 连接 HTTP 响应 一个数字和文字组成的状态码，用来显示请求成功还是失败 响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等 响应体，也就是响应正文 HTTP 状态码HTTP 状态码为 3 位数字。 1xx：指示信息 – 表示请求已接收，继续处理。 2xx：成功 – 表示请求已被成功接收、理解、接受。 3xx：重定向 – 要完成请求必须进行更进一步的操作。 4xx：客户端错误 – 请求有语法错误或请求无法实现。 5xx：服务器端错误 – 服务器未能实现合法的请求。","permalink":"https://singingxy.github.io/2019/HTTP-request/","photos":[]},{"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://singingxy.github.io/tags/VS-Code/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://singingxy.github.io/tags/vue-cli/"},{"name":"eslint","slug":"eslint","permalink":"https://singingxy.github.io/tags/eslint/"}],"title":"使用vue-cli构建项目 eslint报Expected linebreaks to be 'LF' but found 'CRLF'错误","date":"2019/12/07","text":"使用 vue-cli 构建项目 eslint 报 Expected linebreaks to be ‘LF’ but found ‘CRLF’错误。解决方法：进入.eslintrc.js文件，rules里添加&quot;linebreak-style&quot;: [0, &quot;error&quot;, &quot;windows&quot;],如下 rules: &#123; \"linebreak-style\": [0, \"error\", \"windows\"] &#125;","permalink":"https://singingxy.github.io/2019/Expected-linebreaks-to-be-LF-but-found-CRLF/","photos":[]},{"tags":[{"name":"html5","slug":"html5","permalink":"https://singingxy.github.io/tags/html5/"},{"name":"img","slug":"img","permalink":"https://singingxy.github.io/tags/img/"}],"title":"img标签里的srcset和sizes是什么","date":"2019/12/06","text":"在使用 img 标签时，有几个 Emmet 带的扩展里面有两个属性srcset和sizes，很惭愧这么久都没有怎么了解过它们，今天就来好好看看。 定义简单来说这两个属性用于制作“响应式图像”，srcset属性用于适配屏幕不同的像素密度，sizes属性根据srcset来指定不同的图片尺寸。 srcset 以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。每一个字符串由以下组成： 图像的 URL。 可选地，空格后跟以下规则的其中之一： 一个宽度描述符，是一个正整数，后面跟 w符号。该整数宽度除以sizes属性给出的图像大小来计算得到有效的像素密度，即换算成和 x 描述符等价的值。 一个像素密度描述符，这是一个正浮点数，后面紧跟 x 符号。 如果没有指定源描述符，那它会被指定为默认的 1x。 在相同的srcset属性中混合使用宽度描述符和像素密度描述符时，会导致该值无效。 重复的描述符（比如，两个源 在相同的srcset两个源都是2x）也是无效的。 sizes 表示图像大小的以逗号隔开的一个或多个字符串。每一个资源大小包括： 媒体查询。最后一项不能有，用作 fallback。 一个图像尺寸的值。(可以是px,em或者vw,但不能是百分比噢) 资源尺寸的值被用来指定图像的预期尺寸。当srcset使用w描述符时，用户代理使用当前图像大小来选择srcset中合适的一个图像 URL。 被选中的尺寸影响图像的显示大小（如果没有 CSS 样式被应用的话）。如果没有srcset，或者没值，那么这个sizes属性将不起作用。 用法试验之前说一句，由于 Chrome 会优先选择缓存图片而不是恰好适配的那个，所以推荐用火狐，可以实时预览变化。 话不多说直接看写法, srcset 属性格式：图片地址 宽度描述 w 像素密度描述 x，多个资源之间用逗号分隔。 下面是使用像素密度描述x的例子，浏览器根据当前设备的像素密度来选择相应的图片加载。 &lt;img srcset=\"320.png, 480.png 2x, 640.png 3x\" src=\"640.png\" /&gt; 下面是使用宽度描述w的例子，当浏览器宽度超过 320px 时加载 320.png，宽度超过 480px 时加载 480.png，宽度超过 640px 时加载 640.png。 &lt;img srcset=\"320.png 320w, 480.png 480w, 640.png 640w\" src=\"640.png\" /&gt; 以上用法图片所占的区域大小是固定的，适合显示所占区域一样大小的图片。那么如果需要在不同屏幕大小下使用不同尺寸的图片，就需要配合sizes属性来使用。 sizes 属性格式：媒体查询 宽度描述（支持 px），多条规则用逗号分隔。下面例子浏览器宽度小于 320px 时图片宽度为 100vw，浏览器宽度小于 480px 时图片宽度为 50vw，其他情况图片宽度为 20vw &lt;img srcset=\"320.png 320w, 480.png 480w, 640.png 640w\" sizes=\"(max-width: 320px) 100vw,(max-width: 480px) 50vw, 20vw\" src=\"640.png\" /&gt; 要注意，sizes属性必须与srcset属性搭配使用，单独使用无效。","permalink":"https://singingxy.github.io/2019/srcset-size/","photos":[]},{"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://singingxy.github.io/tags/VS-Code/"},{"name":"编码","slug":"编码","permalink":"https://singingxy.github.io/tags/%E7%BC%96%E7%A0%81/"}],"title":"如何让VS Code按照文件原本编码打开文件","date":"2019/11/30","text":"VS Code 默认是使用 UTF-8 格式来打开文件的，如果遇到 GBK 或者 gb2312 格式的文件，里面的中文就会变成乱码。一般情况下可以点击下方的UTF-8按钮来做转换，点击后会出现“通过编码重新打开”和“通过编码保存”两个选项，选择相应的编码转换就可以了。 但是如果经常接触到 gbk 或 gb2312 格式的文件，上面的方法未免显得太麻烦，最好是让编辑器应用文件本身的编码来打开文件。 可以依次点文件–首选项–设置来打开设置，然后找到文本编辑器-文件把 Auto Guess Encoding 这一项的勾选上。如果觉得在界面里寻找比较麻烦也可以直接在设置的搜索框里输入AutoGuessEncoding,也可以找到这一项设置。可以看到这一项的功能是打开文件时猜测字符编码，有一定失败的可能。 设置完以后在遇到 gbk 格式的文件就方便多啦。","permalink":"https://singingxy.github.io/2019/VS-Code-encoding/","photos":[]},{"tags":[{"name":"hexo","slug":"hexo","permalink":"https://singingxy.github.io/tags/hexo/"}],"title":"hexo主题文件不能push","date":"2019/11/27","text":"搭这个博的时候发现，hexo 内themes文件夹里我们使用的主题文件是不往云端同步的，在 GitHub 上访问可以看到这样的图标， 是一个无法点击的文件夹。 但是主题里有我自己的配置、自己修改的样式，如果不能同步，岂不是每次 clone 的时候都要重新配？那也太麻烦了。 因为这个是一个 clone 下来的文件，相当于一个独立的仓库，别人的项目我们当然是不能 push 的，所以我们要做的是让这个文件夹脱离当前的状态，变成我们项目内的一个正常文件夹。 把文件夹复制到项目外的位置，然后项目里的文件夹删除，直接剪切也可以，然后 push 一下，可以在 GitHub 里看见主题文件已经被删掉了。 然后把文件夹里的.git删掉，重新把主题文件复制回来，再次 push。 到 GitHub 上看看， 这个文件已经变成一个可以点击的正常文件夹啦。","permalink":"https://singingxy.github.io/2019/hexo-themes-push/","photos":[]},{"tags":[{"name":"Windows10","slug":"Windows10","permalink":"https://singingxy.github.io/tags/Windows10/"},{"name":"内存占用","slug":"内存占用","permalink":"https://singingxy.github.io/tags/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"}],"title":"WIN10开机内存占用过高","date":"2019/11/26","text":"最近两天发现电脑变得很卡，明明什么软件都没有开，内存占用却达到了 80%以上，在此基础上无论是再打开什么软件都会让电脑卡死。 看了任务管理器也没看到什么占用内存的进程，最多的也就占了几十 M 的样子，不至于吧。 在 Windows 管理工具里找到Windows 内存诊断运行，提示重启，等待诊断结束。 开机后发现内存占用降到了 27%，问题解决了。","permalink":"https://singingxy.github.io/2019/WIN10%E5%BC%80%E6%9C%BA%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/","photos":[]},{"tags":[{"name":"hexo","slug":"hexo","permalink":"https://singingxy.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://singingxy.github.io/tags/blog/"}],"title":"来用hexo和GitHub Pages做个个人博客吧","date":"2019/11/25","text":"为什么选 hexoGitHub Pages 的配置页面里推荐了 Jekyll，本来打算就从 Jekyll 开始摸索的，去主页看了文档，需要 Ruby 和 RubyGems ，光是下载 Ruby 这一步就把我卡住了，下载速度为 0。行吧。只能把目光转向了 hexo，一看环境只需要 node.js，用 npm 直接安装就可以，太方便了。 开始安装先把 hexo 装上 npm install -g hexo-cli 然后用 init 初始化 hexo init &lt;folder&gt; cd &lt;folder&gt; npm install 别看就这么短短 3 句话，也有的折腾的。init 这一步由于要下载一个默认的主题包，文件还不小，下了一会儿速度就变 0 了，继续等，结果直接超时了，报了一堆错，基本就是说下载失败什么的。只能重新开始又下了一遍，耐心等待，这回终于成功了。 _config.yml是配置文件，自定义的属性就在里面设置。 部署到 GitHub Pages到_config.yml文件里拉到最下面找到 deploy 配置： deploy: type: git repo: https://github.com/singingXY/singingXY.github.io.git branch: master 填上自己的仓库地址和分支名就可以使用了。 发出第一篇文章下面是几个常用的命令，步骤是：新建文章-生成-本地预览-部署到线上 hexo n \"xxx\" == hexo new \"xxx\" #新建文章 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署 除了上面的写法，我们在自动生成的package.json文件里可以看到如下配置， \"scripts\": &#123; \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\" &#125; 习惯 npm 的也可以用npm run的形式写。 使用另一个分支保存源码由于master分支里保存的是我们生成出来的文件，而源码是存在本地的，为了当我换一台电脑也能继续更新，我需要把源码存到 github 里，所以新建了一个hexo分支，把源码存在里面。这样当我源码有改动时也能同步更新了。 开始写文章啦当我们执行hexo new的命令后，会在 source 文件夹下看到我们新建的.md文件，顶端以---分隔的区域，叫做 Front-matter，我们可以在里面配置这篇文章的信息。如果要给文章添加 tags 和分类，可以如下设置 categories: - Diary tags: - PS3 - Games Front-matter 的下面就可以开始用 markdown 的语法写文章了。 使用本地图片插件 hexo-asset-image先将_config.yml的post_asset_folder改为 true，然后运行以下命令： npm install https://github.com/CodeFalling/hexo-asset-image --save 这样可以解决在使用本地图片时，本地图片和线上图片路径不一致的问题，本地预览时也可以显示出图片。而且不用把分散的文章里的图片都放在一个总的 source 文件夹内，而是按照文章目录来放置，简单明了。","permalink":"https://singingxy.github.io/2019/%E6%9D%A5%E7%94%A8hexo%E5%92%8CGitHub%20Pages%E5%81%9A%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%90%A7/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/11/25","text":"突发奇想搭了一个 blog。以后用来记一下自己遇到和解决的问题吧，与其放在脑子里渐渐忘掉不如写下来作为纪念。","permalink":"https://singingxy.github.io/2019/hello-world/","photos":[]}]}